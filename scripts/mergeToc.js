"use strict";

let fs = require('fs-extra');
let path = require('path');
let yaml = require('js-yaml');

let yamlOption = {
    "lineWidth": -1
}

let targetTocFilePath = "docs-ref-autogen\\toc.yml";
if (fs.existsSync(targetTocFilePath)) {
    fs.removeSync(targetTocFilePath);
}

// find all toc.yml and metadata files inside docs-ref-autogen and docs-ref-manual respectively
let apiRefInfo = traverseApiToc("docs-ref-autogen");
let apiRefManualInfo = traverseApiToc("docs-ref-manual");

// check if any metadata files has duplicated uid
checkDuplicateUid(apiRefInfo.ymlList.concat(apiRefManualInfo.ymlList));

// all toc.yml except toc.yml generated by this script
let tocFiles = apiRefInfo.tocList.concat(apiRefManualInfo.tocList);
let targetTocModels = [];

tocFiles.forEach(tocFile => {
    let tocModel = yaml.safeLoad(fs.readFileSync(tocFile, "utf8"));
    let tocDir = path.dirname(tocFile);
    tocModel.forEach(ns => {
        // add `!` to distinguish original folder
        let nsTocFilePath = path.join(tocDir, '!' + ns.uid, "toc.yml")
        let nsTocRelativePath = path.relative("docs-ref-autogen", nsTocFilePath);
        let nsTocDir = path.dirname(nsTocFilePath);
        if (!fs.existsSync(nsTocDir)) {
            fs.mkdirsSync(nsTocDir);
        }

        fs.writeFileSync(nsTocFilePath, yaml.safeDump([{"uid": ns.uid, "name": ns.name, "items": ns.items}], yamlOption), "utf8");
        console.log(nsTocFilePath);
        targetTocModels.push({"uid": ns.uid, "name": ns.name, "href": path.dirname(nsTocRelativePath).replace('\\', '/')+ "/"});
    });
});

fs.writeFileSync(targetTocFilePath, yaml.safeDump(targetTocModels, yamlOption), "utf8");

// clean all original toc.yml
tocFiles.forEach(tocFile => {
    fs.removeSync(tocFile);
});

// merge all toc.yml into one
// mergeToc();

function checkDuplicateUid(ymlList) {
    let record = new Set();
    ymlList.forEach(function (yml) {
        if (record.has(yml)) {
            console.error("Error: duplicated UID found, " + yml);
            process.exit(1);
        } else {
            record.add(yml);
        }
    });
}

function traverseApiToc(homeDir) {
    let apiInfo = {
        tocList: [],
        ymlList: []
    };

    if (!fs.existsSync(homeDir)) {
        return apiInfo;
    }

    fs.readdirSync(homeDir).forEach(file => {
        let filePath = path.join(homeDir, file);
        // only search toc.yml in original folder
        if (filePath.indexOf('!') === -1) {
            if (fs.lstatSync(filePath).isFile()) {
                if (file === "toc.yml") {
                    apiInfo.tocList.push(filePath);
                } else if (path.extname(file) === ".yml") {
                    apiInfo.ymlList.push(file);
                }
            } else {
                let otherapiRefInfo = traverseApiToc(filePath)
                apiInfo.tocList = apiInfo.tocList.concat(otherapiRefInfo.tocList);
                apiInfo.ymlList = apiInfo.ymlList.concat(otherapiRefInfo.ymlList);
            }
        }
    });
    return apiInfo;
}


function mergeToc(tocList, destToc) {
    let content = "";
    tocList.forEach(function (toc) {
        if (content === "") {
            content = fs.readFileSync(toc, "utf8");
        } else {
            content = content + fs.readFileSync(toc, "utf8");
        }
    });
    fs.writeFileSync(destToc, content, "utf8");
}